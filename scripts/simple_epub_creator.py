#!/usr/bin/env python3
"""
Simple EPUB Creator for Auto-Novel Snowflake Engine
Creates basic EPUB files without external dependencies
"""

import os
import zipfile
import uuid
from pathlib import Path
from datetime import datetime

def create_epub_structure(title, author, chapters, output_path):
    """Create a basic EPUB file structure"""
    
    # Create temporary directory structure
    temp_dir = Path(output_path).parent / "epub_temp"
    temp_dir.mkdir(exist_ok=True)
    
    try:
        # Create META-INF directory
        meta_inf = temp_dir / "META-INF"
        meta_inf.mkdir(exist_ok=True)
        
        # Create container.xml
        with open(meta_inf / "container.xml", "w", encoding="utf-8") as f:
            f.write('''<?xml version="1.0" encoding="UTF-8"?>
<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
    <rootfiles>
        <rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/>
    </rootfiles>
</container>''')
        
        # Create OEBPS directory
        oebps = temp_dir / "OEBPS"
        oebps.mkdir(exist_ok=True)
        
        # Create content.opf
        book_id = str(uuid.uuid4())
        with open(oebps / "content.opf", "w", encoding="utf-8") as f:
            f.write(f'''<?xml version="1.0" encoding="UTF-8"?>
<package xmlns="http://www.idpf.org/2007/opf" unique-identifier="BookId" version="2.0">
    <metadata xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:opf="http://www.idpf.org/2007/opf">
        <dc:identifier id="BookId">{book_id}</dc:identifier>
        <dc:title>{title}</dc:title>
        <dc:creator opf:role="aut">{author}</dc:creator>
        <dc:language>en</dc:language>
        <dc:subject>Techno-Thriller</dc:subject>
        <dc:description>A techno-thriller novel generated by the Auto-Novel Snowflake Engine</dc:description>
        <dc:date>{datetime.now().strftime('%Y-%m-%d')}</dc:date>
        <meta name="cover" content="cover-image"/>
    </metadata>
    <manifest>
        <item id="ncx" href="toc.ncx" media-type="application/x-dtbncx+xml"/>
        <item id="titlepage" href="titlepage.xhtml" media-type="application/xhtml+xml"/>''')
            
            # Add chapter items to manifest
            for i in range(len(chapters)):
                f.write(f'\n        <item id="chapter{i+1}" href="chapter{i+1}.xhtml" media-type="application/xhtml+xml"/>')
            
            f.write('''
    </manifest>
    <spine toc="ncx">
        <itemref idref="titlepage"/>''')
            
            # Add chapter items to spine
            for i in range(len(chapters)):
                f.write(f'\n        <itemref idref="chapter{i+1}"/>')
            
            f.write('''
    </spine>
</package>''')
        
        # Create toc.ncx
        with open(oebps / "toc.ncx", "w", encoding="utf-8") as f:
            f.write(f'''<?xml version="1.0" encoding="UTF-8"?>
<ncx xmlns="http://www.daisy.org/z3986/2005/ncx/" version="2005-1">
    <head>
        <meta name="dtb:uid" content="{book_id}"/>
        <meta name="dtb:depth" content="1"/>
        <meta name="dtb:totalPageCount" content="0"/>
        <meta name="dtb:maxPageNumber" content="0"/>
    </head>
    <docTitle>
        <text>{title}</text>
    </docTitle>
    <navMap>
        <navPoint id="titlepage" playOrder="1">
            <navLabel>
                <text>Title Page</text>
            </navLabel>
            <content src="titlepage.xhtml"/>
        </navPoint>''')
            
            # Add navigation points for chapters
            for i, chapter in enumerate(chapters):
                f.write(f'''
        <navPoint id="chapter{i+1}" playOrder="{i+2}">
            <navLabel>
                <text>{chapter['title']}</text>
            </navLabel>
            <content src="chapter{i+1}.xhtml"/>
        </navPoint>''')
            
            f.write('''
    </navMap>
</ncx>''')
        
        # Create title page
        with open(oebps / "titlepage.xhtml", "w", encoding="utf-8") as f:
            f.write(f'''<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>{title}</title>
    <style type="text/css">
        body {{ font-family: serif; text-align: center; margin: 2em; }}
        .title {{ font-size: 2em; font-weight: bold; margin: 2em 0; }}
        .subtitle {{ font-size: 1.2em; margin: 1em 0; }}
        .author {{ font-size: 1.5em; margin: 2em 0; }}
    </style>
</head>
<body>
    <div class="title">{title}</div>
    <div class="subtitle">A Techno-Thriller Novel</div>
    <div class="author">By {author}</div>
</body>
</html>''')
        
        # Create chapter files
        for i, chapter in enumerate(chapters):
            with open(oebps / f"chapter{i+1}.xhtml", "w", encoding="utf-8") as f:
                # Clean and format chapter content
                content = chapter['content']
                # Split into paragraphs
                paragraphs = [p.strip() for p in content.split('\n\n') if p.strip()]
                
                f.write(f'''<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>{chapter['title']}</title>
    <style type="text/css">
        body {{ font-family: serif; line-height: 1.6; margin: 1em; }}
        .chapter-title {{ font-size: 1.5em; font-weight: bold; text-align: center; margin: 2em 0; }}
        p {{ text-indent: 1em; margin: 0 0 1em 0; }}
    </style>
</head>
<body>
    <h1 class="chapter-title">{chapter['title']}</h1>''')
                
                for para in paragraphs:
                    if para and not para.startswith('**Chapter'):
                        # Clean up any remaining markdown
                        para = para.replace('**', '').replace('*', '')
                        f.write(f'\n    <p>{para}</p>')
                
                f.write('''
</body>
</html>''')
        
        # Create the EPUB file (ZIP archive)
        with zipfile.ZipFile(output_path, 'w', zipfile.ZIP_DEFLATED) as epub:
            # Add mimetype first (uncompressed)
            epub.writestr('mimetype', 'application/epub+zip', compress_type=zipfile.ZIP_STORED)
            
            # Add all other files
            for root, dirs, files in os.walk(temp_dir):
                for file in files:
                    file_path = Path(root) / file
                    arc_path = file_path.relative_to(temp_dir)
                    epub.write(file_path, arc_path)
        
        print(f"EPUB created successfully: {output_path}")
        
    finally:
        # Clean up temporary directory
        import shutil
        if temp_dir.exists():
            shutil.rmtree(temp_dir)

if __name__ == "__main__":
    # This will be called from the main export script
    pass